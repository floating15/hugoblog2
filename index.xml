<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on haoming&#39;s blog</title>
    <link>/</link>
    <description>Recent content in Home on haoming&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>R - 1. Base R</title>
      <link>/post/2022/03/09/r-1.-base-r/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>/post/2022/03/09/r-1.-base-r/</guid>
      <description>1. Vectors Vectors are one-dimension arrays that can hold numeric data, character data, or logical data. In other words, a vector is a simple tool to store data. For example, you can store your daily gains and losses in the casinos.
In R, you create a vector with the combine function c(). You place the vector elements separated by a comma between the parentheses. For example:
vec1 &amp;lt;- c(1, 2, 3) vec2 &amp;lt;- c(&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;) vec3 &amp;lt;- c(TRUE, FALSE, TRUE) You can give a name to the elements of a vector with the names() function.</description>
    </item>
    
    <item>
      <title>Kaggle - ASHRAE, Great Energy Predictor III</title>
      <link>/post/2021/07/23/kaggle-ashrae-great-energy-predictor-iii/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/07/23/kaggle-ashrae-great-energy-predictor-iii/</guid>
      <description>预测建筑物的能源消耗 ASHRAE（American Society of Heating, Refrigerating and Air-Conditioning Engineers），中文名称“美国采暖、制冷与空调工程师学会”，于1894年在美国纽约成立，是由暖通空调（HVAC）工程师所组成的学会，全球拥有超过54,000名成员。协会及其成员专注于建筑系统、能源效率、室内空气质量、制冷和行业内的可持续性。通过调研、标准编写、出版和继续教育，ASHRAE发展至现在的规模。
问：夏天给大楼降温需要多少钱？
答：非常多！政府正在进行投资，以降低能源成本，减少排放。但是问题是，这些改进是否真的有效？
在这次竞赛中，我们通过预测冷水表、电表、热水表和蒸汽表的读数来对这些节能投资进行更好的估计。数据来自近三年来1000栋建筑中的各表读数。大型投资者和金融机构将更倾向于在这一领域投资，以提高建筑能源使用效率。
我们将这个notebook分为不同的步骤，你可以使用下面的链接来浏览此notebook。
 Step 1: 导入数据 Step 2: 探索性数据分析 Step 3: 数据预处理 Step 4: LightGBM Step 5: 结果预测  在该项目中包含了如下的问题：
 问题 1: 回顾课上内容并查阅资料，归纳总结数据预处理需要的步骤。 问题 2: 思考此处为何要进行对数转换。 问题 3: 查阅资料，总结LightGBM与CatBoost的差异。  #导入必要的库 import pandas as pd import numpy as np import os import gc import copy import warnings import lightgbm as lgb from lightgbm import LGBMRegressor from sklearn.metrics import mean_squared_log_error from sklearn.</description>
    </item>
    
    <item>
      <title>Perceptron Learning Algorithm</title>
      <link>/post/2020/03/04/perceptron-learning-algorithm/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/03/04/perceptron-learning-algorithm/</guid>
      <description>import numpy as np import pandas as pd import matplotlib.pyplot as plt %matplotlib inline Linear separable Generate the data: randlist1 = np.array([np.random.uniform(-5,5) for i in range(500)]) randlist2 = np.array([np.random.uniform(0,3) for i in range(500)]) data_p1_0 = pd.DataFrame( { &amp;#34;x0&amp;#34;: 1, &amp;#34;x1&amp;#34;: randlist1, &amp;#34;x2&amp;#34;: randlist1 + randlist2, &amp;#34;y&amp;#34; : -1 } ) data_m1_0 = pd.DataFrame( { &amp;#34;x0&amp;#34;: 1, &amp;#34;x1&amp;#34;: randlist1, &amp;#34;x2&amp;#34;: randlist1 - randlist2, &amp;#34;y&amp;#34; : +1 } ) df = pd.concat([data_m1_0, data_p1_0], axis=0) PLA model plt.</description>
    </item>
    
    <item>
      <title>Mermaid</title>
      <link>/post/2020/01/03/mermaid/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/01/03/mermaid/</guid>
      <description>概述  什么是Mermaid？  Mermaid是一种基于Javascript的绘图工具，使用类似于Markdown的语法，使用户可以方便快捷地通过代码创建图表。 项目地址：https://github.com/mermaid-js/mermaid（需要将梯子设置成全局模式才能访问）      怎么使用Mermaid？
 使用特定的Mermaid渲染器； **使用集成了Mermaid渲染功能的Markdown编辑器，如Typora。**使用时，需要将代码块的语言选择为Mermaid。   Typora是宇宙第一笔记软件，不接受反驳
   Mermaid能绘制哪些图？
 饼状图：使用pie关键字，具体用法后文将详细介绍 流程图：使用graph关键字，具体用法后文将详细介绍 序列图：使用sequenceDiagram关键字 甘特图：使用gantt关键字 类图：使用classDiagram关键字 状态图：使用stateDiagram关键字 用户旅程图：使用journey关键字    实例：朱元璋家谱简图，圆圈代表皇帝
  graph LRemperor((朱八八))-.子.-father(朱五四)-.子.-朱四九-.子.-朱百六朱雄英--长子--朱标--长子--emperoremperor2((朱允炆))--次子--朱标朱樉--次子--emperor朱棡--三子--emperoremperor3((朱棣))--四子--emperoremperor4((朱高炽))--长子--emperor3 以上是概述，下面详细介绍饼状图和流程图的语法。其他图的语法可访问上文给出的项目地址，自行学习。（记得挂梯子）
饼状图   在线渲染器：Online FlowChart &amp;amp; Diagrams Editor（需要梯子）
  语法
 从pie关键字开始图表 然后使用title关键字及其在字符串中的值，为饼图赋予标题。（这是可选的） 数据部分  在&amp;quot; &amp;quot;内写上分区名。 分区名后使用:作为分隔符 分隔符后写上数值，最多支持2位小数——数据会以百分比的形式展示       实例  pietitle 为什么总是宅在家里？&#34;</description>
    </item>
    
    <item>
      <title>Git - Rebase (in Chinese)</title>
      <link>/post/2019/08/05/git-rebase-in-chinese/</link>
      <pubDate>Mon, 05 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/08/05/git-rebase-in-chinese/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Git - 3. Host code by Github (in Chinese)</title>
      <link>/post/2019/08/02/git-3.-host-code-by-github-in-chinese/</link>
      <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/08/02/git-3.-host-code-by-github-in-chinese/</guid>
      <description>1. Github 1.1 上传 push git push 命用于从将本地的分支版本上传到远程并合并。命令格式如下：
git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt; 如果本地分支名与远程分支名相同，则可以省略冒号：
git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt; 删除主机的分支可以使用 &amp;ndash;delete 参数，以下命令表示删除 origin 主机的 master 分支：
git push origin --delete master  首先创建一个 github 仓库 git_exercise，复制其地址。在 git 中设置该 github 仓库的地址：
(base) wanghaoming@localhost git_test % git remote add origin https://github.com/git_username/git_exercise.git 这行命令为对该 git_exercise 仓库起一个别名 origin（也可以取其他别名），这一点在 git_test/.git/config 文件中可以看到：
(base) wanghaoming@localhost git_test % cat ./.git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote &amp;#34;origin&amp;#34;] url = https://github.</description>
    </item>
    
    <item>
      <title>Git - 2. Branch (in Chinese)</title>
      <link>/post/2019/07/26/git-2.-branch-in-chinese/</link>
      <pubDate>Fri, 26 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/07/26/git-2.-branch-in-chinese/</guid>
      <description>1. 分支简介 假设在版本 1 （V1）中一共写入 100 个文件；在 V2 中修改了 V1 中的 10 个文件，并新写入 20 个文件。则 Git 在生成 V2 时，会只生成新变化的 30 个文件，并通过指针指向 V1 从而链接未改变的 90 个文件，提升效率。
扩展这一过程，此时 A，B 两台电脑可以在 V2 的基础上分别开发不同的功能，并生成 V3，V4，这一就形成了两个分支：
当 A，B 完成开发后，可以将两分支汇合生成 V5：
考虑如下一种工作流程：若项目（C3）目前需求开发一项新功能，则可以为其创建一个分支（如 dev 分支），并在该分支上不断开发。若在开发的过程中发现原项目（C3）存在 bug，在可以在 C3 再创建一个 bug 分支，并在该分支上修改 bug。当 dev 分支与 bug 分支上的工作都已完成，再将这两分支合并到 Master 上。（Master 是 git 版本管理的默认主干）
分支可以创建一个相互隔离的环境，从而让开发者各自完成工作再合并。
2. 分支命令 继续以 ~/Documents/git_test 为例，如下是版本历史：
(base) wanghaoming@localhost git_test % git log commit 1954fae802221ffd98fa26512275a4817ff3dc5d (HEAD -&amp;gt; master) Author: git_username &amp;lt;git_username@163.</description>
    </item>
    
    <item>
      <title>Git - Intro</title>
      <link>/post/2019/07/23/git-intro/</link>
      <pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/07/23/git-intro/</guid>
      <description>1. Git intro Git 是一个分布式版本控制软件。版本控制的方式一共经历过四个发展阶段：
 文件管理 本地管理软件 集中式管理软件，以 SVN 为代表 分布式管理软件，以 Git 为代表  在 Git 中，用户本地与云端服务器中都存在版本仓库。当用户打算更新版本时，需要将新版本文件推送到本地仓库，再推送到云端仓库。用户也可以多次将新版本推送到本地仓库，再统一推送到云端仓库。因此所云端服务器崩溃，不影响用户的版本控制。
在本地安装 Git 后，可以在本地进行版本控制；若要将版本代码上传至云端仓库，需要链接 Github, Gitlab 账户等。
2. Git 三大分区 Git 有三种状态，你的文件可能处于其中之一： 已暂存（staged）、已修改（modified） 和已提交（committed） 。
 已修改（modified）表示修改了文件，但还没保存到数据库中。 已暂存（staged）表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交（committed）表示数据已经安全地保存在本地数据库中。  这会让我们的 Git 项目拥有三个阶段：工作区、暂存区、版本库。基本的 Git 工作流程如下：
 在工作区中修改文件，文件状态变为 modified。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区，文件状态变为 staged。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录，文件状态变为 committed。  3. Git 命令基础 本文以文件 ~/Documents/git_test/items.py 为例，如下：
3.0 忽略 .DS_Store 文件 Mac OS 系统会自动在每个目录中生成一个隐藏的 .DS_Store 文件。默认情况下 Git 会把 DS_Store 文件代入版本控制的范围内，从而与 Git 中的某些功能产生冲突。所以，需要在对项目进行版本管理之前设置 Git 忽略.</description>
    </item>
    
    <item>
      <title>Summary of Data Cleaning Skills</title>
      <link>/post/2019/07/08/summary-of-data-cleaning-skills/</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/07/08/summary-of-data-cleaning-skills/</guid>
      <description>Summary df.head(n) df.sample(n) df.info() df.describe() df.shape df.values df.columns df.index Sort df.sort_values( by=&amp;#34;col_name&amp;#34;, axis=0, ascending=True, inplace=False ) df.sort_index( level=[&amp;#34;outter_index&amp;#34;, &amp;#34;inner_index&amp;#34;], ascending=False ) Set index df.set_index(&amp;#34;col&amp;#34;) df.ser_index(&amp;#34;outter_index&amp;#34;, &amp;#34;inner_index&amp;#34;) df.reset_index() df.reset_index(drop=False) Subset and Slice # subset by row df[df[&amp;#34;col&amp;#34;] &amp;gt; 0] df[ (df.col1 &amp;gt; 0) &amp;amp; (df.col2 &amp;gt;0) ] df[ df.col.isin([&amp;#34;xxx&amp;#34;, &amp;#34;yyy&amp;#34;]) ] # with loc method df.loc[ [&amp;#34;outer_index1&amp;#34;, &amp;#34;outer_index_2&amp;#34;] ] df.loc[ [ (&amp;#34;outer_index_1&amp;#34;, &amp;#34;inner_index_1&amp;#34;), (&amp;#34;outer_index_2&amp;#34;, &amp;#34;inner_index_2&amp;#34;), (&amp;#34;outer_index_3&amp;#34;, &amp;#34;inner_index_3&amp;#34;), ] ] df.loc[ &amp;#34;outer_index_i&amp;#34; : &amp;#34;outer_index_j&amp;#34; ] df.</description>
    </item>
    
    <item>
      <title>Python - 1. Data Manipulation with pandas</title>
      <link>/post/2018/08/08/python-1.-data-manipulation-with-pandas/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/08/08/python-1.-data-manipulation-with-pandas/</guid>
      <description>import pandas as pd import numpy as np 1. Transforming DataFrames 1.1 Introducing DataFrames Inspecting a DataFrame When you get a new DataFrame to work with, the first thing you need to do is explore it and see what it contains. pandas has several methods for this.
head method (.head()) returns the first few rows of the DataFrame.
# create a DataFrame cate = [&amp;#34;Py&amp;#34;, &amp;#34;R&amp;#34;, &amp;#34;Matlab&amp;#34; ] df = pd.</description>
    </item>
    
    <item>
      <title>操作目录和文件</title>
      <link>/post/2018/07/23/%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 23 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/07/23/%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6/</guid>
      <description>C04.操作目录和文件 4.1 通配符 shell 提供一种特殊字符，帮助快速指定一组文件名，这种特殊字符叫做通配符（wildcard）。使用通配符的过程称为通配符匹配（globbing）。
   通配符 含义     * 匹配任意多个字符   ？ 匹配任意单个字符   [abc] 匹配属于字符集和 abc 中任意单个字符   [!abc] 匹配不属于字符集和 abc 中任意单个字符   [[:calss:]] 匹配属于字符类 class 的任意单个字符    常用字符类：
   字符类 含义     [:alnum:] 任意单个字母数字   [:alpha:] 任意单个字母   [:digit:] 任意单个数字   [:lower:] 任意单个小写字母   [:upper:] 任意单个大写字母      传统 Unix 可以使用形如[A-Z]或[a-z]来表示字符范围写法，但是一旦配置不当可能产生以外结果。 通配符用来指定文件名（或目录名），若要指定的文件并非当前工作目录的文件，前面需要加上绝对/相对路径。   一些通配符示例：</description>
    </item>
    
    <item>
      <title>Matplotlib - 04. Configure graphics (in Chinese)</title>
      <link>/post/2018/06/12/matplotlib-04.-configure-graphics-in-chinese/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/06/12/matplotlib-04.-configure-graphics-in-chinese/</guid>
      <description>import matplotlib.pyplot as plt import numpy as np %matplotlib inline plt.style.use(&amp;#39;seaborn-whitegrid&amp;#39;) 1. 配置图例 1.1 图例风格 plt.legend()命令会自动创建一个包含每个图形元素的图例，这些图例将根据图形元素的 color，style，marker，label生成：
x = np.linspace(-1, 1, 200) func = lambda x: 2*x**3 - x**2 - 2*x plt.figure(figsize=(8,6)) plt.plot(x, func(x), &amp;#39;-b&amp;#39;, label=&amp;#39;func&amp;#39;) plt.plot(x, func(x)*3, &amp;#39;--r&amp;#39;, label=&amp;#39;func * 3&amp;#39;) plt.axis(&amp;#39;tight&amp;#39;) plt.legend() &amp;lt;matplotlib.legend.Legend at 0x7f7ec2969550&amp;gt;  y_1 = 2*x + np.random.rand(*x.shape)*0.3 y_2 = x**2+np.random.randn(*x.shape)*0.3 plt.figure(figsize=(8,6)) plt.plot(x, y_1, &amp;#39;rv&amp;#39;, label=&amp;#39;red&amp;#39;) plt.plot(x, y_2, &amp;#39;bo&amp;#39;, label=&amp;#39;bule&amp;#39; ) plt.legend() &amp;lt;matplotlib.legend.Legend at 0x7f7e817749a0&amp;gt;  通过对 plt.</description>
    </item>
    
    <item>
      <title>Matplotlib - 03. Error Lines, Contour Plots and Histograms (in Chinese)</title>
      <link>/post/2018/06/09/matplotlib-03.-error-lines-contour-plots-and-histograms-in-chinese/</link>
      <pubDate>Sat, 09 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/06/09/matplotlib-03.-error-lines-contour-plots-and-histograms-in-chinese/</guid>
      <description>1. 误差线 import numpy as np import matplotlib.pyplot as plt plt.style.use(&amp;#39;seaborn-white&amp;#39;) %matplotlib inline 误差线可以通过 plt.errorbar() 函数来创建：
plt.errorbar(x, y, yerr=None, xerr=None, fmt=&amp;#39;&amp;#39;, ecolor=None, elinewidth=None, capsize=None, capthick=None ) 主要参数：
 x, y: 列表，数据点的位置坐标 xerr, yerr: 标量或列表，数据的误差范围 fmt: 数据点的标记样式以及相互之间连接线样式，与 plt.plot 的缩写代码一致 ecolor: 误差棒的线条颜色 elinewidth: 误差棒的线条粗细 capsize: 误差棒边界横杠的大小 capthick: 误差棒边界横杠的厚度 ms: 数据点的大小 mfc: 数据点的颜色 mec: 数据点边缘的颜色  x = np.linspace(0, 10, 50) dy = 0.8 y = np.sin(x) + 0.5 * x + dy * np.</description>
    </item>
    
    <item>
      <title>Matplotlib - 02. Line  and Scatter Diagram (in Chinese)</title>
      <link>/post/2018/06/06/matplotlib-02.-line-and-scatter-diagram-in-chinese/</link>
      <pubDate>Wed, 06 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/06/06/matplotlib-02.-line-and-scatter-diagram-in-chinese/</guid>
      <description>1. 简单线形图 import matplotlib.pyplot as plt %matplotlib inline import numpy as np plt.style.use(&amp;#39;seaborn-whitegrid&amp;#39;) 1.1 绘制线形图 Matplotlib 利用面向对象接口作图时，需要需要先创建一个图形对象 fig 和一个坐标轴对象 ax：
fig = plt.figure() ax = plt.axes() 在 Matplotlib 中，fig (plt.figure 类的一个实例) 可以看成是一个能容纳各种坐标轴、图形、文字、标签的容器；ax (plt.axes 类的一个实例) 是一个带有刻度和标签的矩形，最终包含所有可视化的图形元素。创建好坐标轴后就可以用 ax.plot 作图了（ax.plot 必须与创建的 fig，ax 对象在一起）。在 plt.figure() 中设置参数figuresize可以指定图形的大小，指定参数 dpi可以指定分辨率。
x = np.linspace(0, 10, 1000) fig = plt.figure(figsize=(8, 6)) ax = plt.axes() ax.plot(x, np.sin(x)) [&amp;lt;matplotlib.lines.Line2D at 0x7f8630237ca0&amp;gt;]  观察到图片上方的标识 [&amp;lt;matplotlib.lines.Line2D at 0x7f8670fc8130&amp;gt;]，这说明 plot 函数生成了一个 plt.Line2D 实例。
也可以利用类似 Matlab 接口作图：</description>
    </item>
    
    <item>
      <title>Matplotlib - 01. Intro (in Chinese)</title>
      <link>/post/2018/06/05/matplotlib-01.-intro-in-chinese/</link>
      <pubDate>Tue, 05 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/06/05/matplotlib-01.-intro-in-chinese/</guid>
      <description>import numpy as np import pandas as pd 1. Matplotlib 介绍 1.1 导入Matplotlib plt 是 Matplotlib 最常用的接口
import matplotlib as mpl import matplotlib.pyplot as plt 1.2 设置绘图样式 使用 plt.style.use 来选择图形的绘图风格
plt.style.use(&amp;#39;classic&amp;#39;) 1.3 关于 show() 方法 Matplotlib 是否使用 show() 方法取决于开发环境，一般而言有三种开发环境：1）script；2）IPython Shell；3）IPython Notebook
1.3.1 Script 如果在脚本文件中使用 Matplotlib，显示图形时必须使用 plt.show()。plt.show() 会启动一个 event loop，找到当前所有可用的图形对象，然后打开一个或多个交互式窗口文本。
需要注意，一个 Python session 中只能使用一次 plt.show()，因此通常把它放在脚本最后。
1.3.2 IPython Shell 在该开发环境下，可以通过 %matplotlib 魔法命令开启 Matplotlib 模式，此后不需要使用 plt.show() 了。开启 Matplotlib 模式后任何 plt 命令都会自动打开一个图形窗口，增加新的命令图形就会更新。有时一些变化不会自动及时更新，此时可以使用 plt.draw() 强制更新。</description>
    </item>
    
    <item>
      <title>A Plain Markdown Post</title>
      <link>/post/2016/02/14/a-plain-markdown-post/</link>
      <pubDate>Sun, 14 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2016/02/14/a-plain-markdown-post/</guid>
      <description>This sample post is mainly for blogdown users. If you do not use blogdown, you can skip the first section.
1. Markdown or R Markdown This is a post written in plain Markdown (*.md) instead of R Markdown (*.Rmd). The major differences are:
 You cannot run any R code in a plain Markdown document, whereas in an R Markdown document, you can embed R code chunks (```{r}); A plain Markdown post is rendered through Blackfriday, and an R Markdown document is compiled by rmarkdown and Pandoc.</description>
    </item>
    
    <item>
      <title>Vim intro</title>
      <link>/post/2016/02/14/vim-intro/</link>
      <pubDate>Sun, 14 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2016/02/14/vim-intro/</guid>
      <description>1. vim 模式 normal -&amp;gt; insert
insert -&amp;gt; normal
normal -&amp;gt; visual
visual -&amp;gt; normal
normal &amp;lt;-&amp;gt; command
2. 光标移动 在 normal 模式下：
3. operator  d: cut c: change, i.e. cut and into insert mode y: copy p: paste u: undo vwwww: select to next 4 words from here(visual mode is convenient for select) vjjjp: select 3 lines form here and cut vkd: delect a above line from here  4.</description>
    </item>
    
    <item>
      <title>Intro of Shell</title>
      <link>/post/2015/07/23/intro-of-shell/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/2015/07/23/intro-of-shell/</guid>
      <description>C01.Intro of Shell [TOC]
1.2小试牛刀 1.2.1 Shell提示符 启动终端仿真器，随后出现下面提示符：
root@wanghaoming1:~# 这叫做 Shell 提示符，表明 Shell 已经准备好接受输入，不同 Linux 发行版中提示符格式有所差异，但通常结构为：username@machinename directory $（注意空格）。
若提示符最后一个符号为#表示该终端会话有超级用户权限。这意味着要么我们是以超级用户（root 用户）登录的；要么选用的终端仿真器提供了超级用户权限。
 ~目录就是 root 目录。
 1.2.2 方向键及 tab 按上方向键，提示符后会出现之前输入的历史命令，大部分 Linux 发行版能记住最近输入的 1000 个历史命令
调出历史命令后，按左右方向键可以将光标移动到命令行的任意位置。
输入指令的前部分后，按 tan 键，将补全指令（对目录与文件名也成立）
1.3 几个简单命令  date命令：显示当期的实践和日期  root@wanghaoming1:~# date Mon Feb 14 22:40:48 CST 2022  cal命令：显示当前月份的日历  root@wanghaoming1:~# cal February 2022 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  df命令：查看磁盘的当前可用空间  root@wanghaoming1:~# df Filesystem 1K-blocks Used Available Use% Mounted on udev 2004900 0 2004900 0% /dev tmpfs 404652 2928 401724 1% /run /dev/vda1 41151808 6378304 32660076 17% / tmpfs 2023240 0 2023240 0% /dev/shm tmpfs 5120 0 5120 0% /run/lock tmpfs 2023240 0 2023240 0% /sys/fs/cgroup tmpfs 404652 0 404652 0% /run/user/0  free命令：查看可用内存容量  root@wanghaoming1:~# free total used free shared buff/cache available Mem: 4046484 157700 2828820 3052 1059964 3626368 Swap: 1048572 0 1048572 </description>
    </item>
    
    <item>
      <title>Lorem Ipsum</title>
      <link>/post/2015/07/23/lorem-ipsum/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/2015/07/23/lorem-ipsum/</guid>
      <description>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Quisque mattis volutpat lorem vitae feugiat.</description>
    </item>
    
    <item>
      <title>Lorem Ipsum</title>
      <link>/replicate/2015-07-23-lorem-ipsum/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/replicate/2015-07-23-lorem-ipsum/</guid>
      <description>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Quisque mattis volutpat lorem vitae feugiat.</description>
    </item>
    
    <item>
      <title>导航</title>
      <link>/post/2015/07/23/%E5%AF%BC%E8%88%AA/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/2015/07/23/%E5%AF%BC%E8%88%AA/</guid>
      <description>C02.导航 [TOC]
2.1 文件系统树 Linux 按照有层次的目录结构组织文件。文件是在树状的目录中组织的，目录中可以有文件和其他目录。文件的第一个目录称为根目录（/）。
在 windows 系统中，每个储存设备都有各自独立的文件系统树。而在类 Unix 系统中，不管计算机安装了多少存储设备，都只有一个文件系统树。
2.2 当前的工作目录:pwd 把文件系统想成一座迷宫，形如一个倒置的树，我们就位于其中。在任何时刻，我们都处在某个目录中，能够看到该目录中包含的文件、上级目录（父目录）和下级目录（子目录）。
我们所处的目录称为当前工作目录，可以使用pwd(print working directory)命令将其显示出来：
root@wanghaoming1:~# pwd /root 2.3 列出目录内容:ls 使用ls命令可以列出当前工作目录中的文件与子目录：
root@wanghaoming1:~# ls oneinstack oneinstack-full.tar.gz 2.4更改当前工作目录:cd cd命令可以更改当前工作目录。只需在 cd命令后输入要更改的工作目录路径名即可。路径名分两种：绝对路径名和相对路径名。
2.4.1 绝对路径名 绝对路径名从根目录（用/表示）开始，随后紧接一个又一个分支，直到目标目录或文件：
root@wanghaoming1:~# cd /usr/bin root@wanghaoming1:/usr/bin# pwd /usr/bin  note: 第二行 machinename 和#之间的目录名已经表明当前工作目录为/usr/bin.
 2.4.2 相对路径名 相对路径名从当前工作目录开始使用点表示法描述目标文件系统数中的相对位置：.表示当前工作目录；..表示父目录。假设我们正在目录bin中，若想进入其父目录usr，则有两种方式：
 方式一：绝对路径  root@wanghaoming1:/usr/bin# cd /usr root@wanghaoming1:/usr# pwd /usr  方式二：相对路径  root@wanghaoming1:/usr/bin# cd .. root@wanghaoming1:/usr# pwd /usr 此外还有两种方式从当前目录（usr）进入其子目录bin中，第一种是绝对路径（cd /usr/bin），另一种是相对路径：
root@wanghaoming1:/usr# cd .</description>
    </item>
    
    <item>
      <title>探索 Linux 系统</title>
      <link>/post/2015/07/23/%E6%8E%A2%E7%B4%A2-linux-%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/2015/07/23/%E6%8E%A2%E7%B4%A2-linux-%E7%B3%BB%E7%BB%9F/</guid>
      <description>C03.探索 Linux 系统 [TOC]
3.1 使用ls命令 使用ls命令，可以指定要显示内容的目录：
root@wanghaoming1:/# ls /usr bin games include lib local sbin share src 也可以指定多个目录，既可使用绝对路径，也可使用相对路径。这里用户主目录用~表示：
root@wanghaoming1:/# ls ~ /usr boot boot: abi-4.4.0-62-generic config-4.4.0-62-generic grub initrd.img-4.4.0-62-generic System.map-4.4.0-62-generic vmlinuz-4.4.0-62-generic /root: oneinstack oneinstack-full.tar.gz /usr: bin games include lib local sbin share src root@wanghaoming1:/# cd ~ root@wanghaoming1:~# ls .. bin boot data dev etc home initrd.img lib lib64 lost+found media mnt opt proc root run sbin srv swapfile sys tmp usr var vmlinuz 还可以通过给ls命令添加选项，修改其显示的格式：</description>
    </item>
    
    <item>
      <title>欢迎使用 MWeb</title>
      <link>/post/2015/07/23/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8-mweb/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/2015/07/23/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8-mweb/</guid>
      <description>MWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件，目前已支持 Mac，iPad 和 iPhone。MWeb 有以下特色：
软件本身：  使用原生的 macOS 技术打造，追求与系统的完美结合。 原则上，首先是追求界面简洁和高性能，然后才是强大易用，功能全面。  Markdown 语法：  使用 GitHub Flavored Markdown 语法，简称 GFM 语法。 支持表格、TOC、LaTeX、代码块、任务列表、脚注等。 画图库支持 mermaid, viz, ECharts, PlantUML, Sequence, Flow。  Markdown 辅助：  支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。 在兼容 Markdown 语法的情况下支持设置图片宽度。 好用的表格插入和 LaTeX 书写辅助。  Markdown 输出：  支持导出为图片、HTML、Epub、PDF、RTF、Docx。 支持发布到 WordPress、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记（Evernote）、Blogger、Medium、Tumblr、语雀、Ghost、少数派 Matrix。 图片上传服务（图床）支持 Imgur、七牛云、又拍云、腾讯云 COS、阿里云 OSS、SM.MS和自定义的图床服务。  Markdown 笔记：  强大的文档库支持分类树和标签管理文档，文档可归类于多个分类，可以把分类整个导出为 Epub、PDF 和生成静态网站。非常合适用于笔记、个人知识收集、管理和输出。 快速笔记：随意增加笔记及图片等素材，支持以天为单位把增加的素材组合在一个文档内，方便整理及记录历史收集情况。 快速搜索：目前已支持全局快捷键调出搜索。  外部 Markdown 文档：  外部 Markdown 文档使用外部模式管理。外部模式使用目录树的方式编辑和管理你的 Markdown 文档，还能很好的支持 GitBook、Jekyll、Hexo 等等编辑和图片插入。  MWeb 文档： 如果要更详细了解 MWeb，建议你一定要去看一下官网的帮助文档，网址为：https://zh.</description>
    </item>
    
    <item>
      <title>Notes</title>
      <link>/note/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/note/</guid>
      <description>Machine Learning Foundation I  Perceptron Learning Algorithm.pdf PAC Learning Frame.pdf  </description>
    </item>
    
  </channel>
</rss>
