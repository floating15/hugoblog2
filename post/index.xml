<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on haoming&#39;s blog</title>
    <link>/post/</link>
    <description>Recent content in Posts on haoming&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kaggle - ASHRAE, Great Energy Predictor III</title>
      <link>/post/2021/07/23/kaggle-ashrae-great-energy-predictor-iii/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/07/23/kaggle-ashrae-great-energy-predictor-iii/</guid>
      <description>预测建筑物的能源消耗 ASHRAE（American Society of Heating, Refrigerating and Air-Conditioning Engineers），中文名称“美国采暖、制冷与空调工程师学会”，于1894年在美国纽约成立，是由暖通空调（HVAC）工程师所组成的学会，全球拥有超过54,000名成员。协会及其成员专注于建筑系统、能源效率、室内空气质量、制冷和行业内的可持续性。通过调研、标准编写、出版和继续教育，ASHRAE发展至现在的规模。
问：夏天给大楼降温需要多少钱？
答：非常多！政府正在进行投资，以降低能源成本，减少排放。但是问题是，这些改进是否真的有效？
在这次竞赛中，我们通过预测冷水表、电表、热水表和蒸汽表的读数来对这些节能投资进行更好的估计。数据来自近三年来1000栋建筑中的各表读数。大型投资者和金融机构将更倾向于在这一领域投资，以提高建筑能源使用效率。
我们将这个notebook分为不同的步骤，你可以使用下面的链接来浏览此notebook。
 Step 1: 导入数据 Step 2: 探索性数据分析 Step 3: 数据预处理 Step 4: LightGBM Step 5: 结果预测  在该项目中包含了如下的问题：
 问题 1: 回顾课上内容并查阅资料，归纳总结数据预处理需要的步骤。 问题 2: 思考此处为何要进行对数转换。 问题 3: 查阅资料，总结LightGBM与CatBoost的差异。  #导入必要的库 import pandas as pd import numpy as np import os import gc import copy import warnings import lightgbm as lgb from lightgbm import LGBMRegressor from sklearn.metrics import mean_squared_log_error from sklearn.</description>
    </item>
    
    <item>
      <title>Data Visualization III (Seaborn)</title>
      <link>/post/2020/04/23/data-visualization-iii-seaborn/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/04/23/data-visualization-iii-seaborn/</guid>
      <description>All figures in this blog are embedded by Github Image Hosting Service. These figures may not be displayed on mobile devices.
 [toc]</description>
    </item>
    
    <item>
      <title>Data Visualization II (Seaborn)</title>
      <link>/post/2020/04/20/data-visualization-ii-seaborn/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/04/20/data-visualization-ii-seaborn/</guid>
      <description>All figures in this blog are embedded by Github Image Hosting Service. These figures may not be displayed on mobile devices.
 [toc]
1. Introduction to Seaborn 1.1 Using pandas with Seaborn # Import Matplotlib and Seaborn import matplotlib.pyplot as plt import seaborn as sns To create a count plot with a pandas DataFrame column instead of a list of data, set x (or y) equal to the name of the column in the DataFrame.</description>
    </item>
    
    <item>
      <title>Data Visualization I (Matplotlib)</title>
      <link>/post/2020/04/16/data-visualization-i-matplotlib/</link>
      <pubDate>Thu, 16 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/04/16/data-visualization-i-matplotlib/</guid>
      <description>All figures in this blog are embedded by Github Image Hosting Service. These figures may not be displayed on mobile devices.
 [toc]
1. Introduction to Matplotlib 1.1 Intro to data visualization with matplotlib we will use the main object-oriented interface. This interface is provided through the pyplot submodule. The plt.subplots() command, when called without any inputs, creates two different objects: a Figure object and an Axes object.
import matplotlib.</description>
    </item>
    
    <item>
      <title>Perceptron Learning Algorithm</title>
      <link>/post/2020/03/04/perceptron-learning-algorithm/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/03/04/perceptron-learning-algorithm/</guid>
      <description>import numpy as np import pandas as pd import matplotlib.pyplot as plt %matplotlib inline Linear separable Generate the data: randlist1 = np.array([np.random.uniform(-5,5) for i in range(500)]) randlist2 = np.array([np.random.uniform(0,3) for i in range(500)]) data_p1_0 = pd.DataFrame( { &amp;#34;x0&amp;#34;: 1, &amp;#34;x1&amp;#34;: randlist1, &amp;#34;x2&amp;#34;: randlist1 + randlist2, &amp;#34;y&amp;#34; : -1 } ) data_m1_0 = pd.DataFrame( { &amp;#34;x0&amp;#34;: 1, &amp;#34;x1&amp;#34;: randlist1, &amp;#34;x2&amp;#34;: randlist1 - randlist2, &amp;#34;y&amp;#34; : +1 } ) df = pd.concat([data_m1_0, data_p1_0], axis=0) PLA model plt.</description>
    </item>
    
    <item>
      <title>Object Oriented Programming III (Class)</title>
      <link>/post/2019/08/20/object-oriented-programming-iii-class/</link>
      <pubDate>Tue, 20 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/08/20/object-oriented-programming-iii-class/</guid>
      <description>[toc]
1. OOP Fundamental 1.1 Attributes and Method class Employee: def set_name(self, new_name): self.name = new_name def set_salary(self, new_salary): self.salary = new_salary def give_raise(self, amount): self.salary = self.salary + amount def monthly_salary(self): return self.salary / 12 method = function; attribute = variable
# self 就是对象 object 的替身 emp = Employee() emp.set_salary(1000) # 理解为 set_salary(emp, 10000)  self.salary # 理解为 emp.salary variable 可以打印, 也可以赋值
emp.salary = emp.salary + 5000 # e.t. emp.</description>
    </item>
    
    <item>
      <title>Object Oriented Programming II (Iterators, Comprehensions &amp; Generators)</title>
      <link>/post/2019/08/16/object-oriented-programming-ii-iterators-comprehensions-generators/</link>
      <pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/08/16/object-oriented-programming-ii-iterators-comprehensions-generators/</guid>
      <description>All figures in this blog are embedded by Github Image Hosting Service. These figures may not be displayed on mobile devices.
 [toc]
1. Iterators in PythonLand 1.1 Introduction to iterators When you use a for loop to print out each element of a list, you&amp;rsquo;re iterating over the list. You can also use a for loop to iterate over characters in a string. You can also use a for loop to iterate a over a sequence of numbers produced by a special range object.</description>
    </item>
    
    <item>
      <title>Object Oriented Programming I (Function)</title>
      <link>/post/2019/08/14/object-oriented-programming-i-function/</link>
      <pubDate>Wed, 14 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/08/14/object-oriented-programming-i-function/</guid>
      <description>[toc]
1. Writing Functions 1.1 Define function To define the function, We begin with the keyword def, followed by the function name; this is then followed by a set of parentheses and a colon. This piece of code is called a function header. To complete the function definition, We write the function body inside the indentation.
There&amp;rsquo;s an essential aspect of writing functions in Python: docstrings. Docstrings serve as documentation for your function so that anyone who reads your function&amp;rsquo;s docstring understands what your function does, without having to trace through all the code in the function definition.</description>
    </item>
    
    <item>
      <title>Git - Rebase (in Chinese)</title>
      <link>/post/2019/08/05/git-rebase-in-chinese/</link>
      <pubDate>Mon, 05 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/08/05/git-rebase-in-chinese/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Git - 3. Host code by Github (in Chinese)</title>
      <link>/post/2019/08/02/git-3.-host-code-by-github-in-chinese/</link>
      <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/08/02/git-3.-host-code-by-github-in-chinese/</guid>
      <description>1. Github 1.1 上传 push git push 命用于从将本地的分支版本上传到远程并合并。命令格式如下：
git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt; 如果本地分支名与远程分支名相同，则可以省略冒号：
git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt; 删除主机的分支可以使用 &amp;ndash;delete 参数，以下命令表示删除 origin 主机的 master 分支：
git push origin --delete master  首先创建一个 github 仓库 git_exercise，复制其地址。在 git 中设置该 github 仓库的地址：
(base) wanghaoming@localhost git_test % git remote add origin https://github.com/git_username/git_exercise.git 这行命令为对该 git_exercise 仓库起一个别名 origin（也可以取其他别名），这一点在 git_test/.git/config 文件中可以看到：
(base) wanghaoming@localhost git_test % cat ./.git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote &amp;#34;origin&amp;#34;] url = https://github.</description>
    </item>
    
    <item>
      <title>Git - 2. Branch (in Chinese)</title>
      <link>/post/2019/07/26/git-2.-branch-in-chinese/</link>
      <pubDate>Fri, 26 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/07/26/git-2.-branch-in-chinese/</guid>
      <description>1. 分支简介 假设在版本 1 （V1）中一共写入 100 个文件；在 V2 中修改了 V1 中的 10 个文件，并新写入 20 个文件。则 Git 在生成 V2 时，会只生成新变化的 30 个文件，并通过指针指向 V1 从而链接未改变的 90 个文件，提升效率。
扩展这一过程，此时 A，B 两台电脑可以在 V2 的基础上分别开发不同的功能，并生成 V3，V4，这一就形成了两个分支：
当 A，B 完成开发后，可以将两分支汇合生成 V5：
考虑如下一种工作流程：若项目（C3）目前需求开发一项新功能，则可以为其创建一个分支（如 dev 分支），并在该分支上不断开发。若在开发的过程中发现原项目（C3）存在 bug，在可以在 C3 再创建一个 bug 分支，并在该分支上修改 bug。当 dev 分支与 bug 分支上的工作都已完成，再将这两分支合并到 Master 上。（Master 是 git 版本管理的默认主干）
分支可以创建一个相互隔离的环境，从而让开发者各自完成工作再合并。
2. 分支命令 继续以 ~/Documents/git_test 为例，如下是版本历史：
(base) wanghaoming@localhost git_test % git log commit 1954fae802221ffd98fa26512275a4817ff3dc5d (HEAD -&amp;gt; master) Author: git_username &amp;lt;git_username@163.</description>
    </item>
    
    <item>
      <title>Git - Intro</title>
      <link>/post/2019/07/23/git-intro/</link>
      <pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/07/23/git-intro/</guid>
      <description>1. Git intro Git 是一个分布式版本控制软件。版本控制的方式一共经历过四个发展阶段：
 文件管理 本地管理软件 集中式管理软件，以 SVN 为代表 分布式管理软件，以 Git 为代表  在 Git 中，用户本地与云端服务器中都存在版本仓库。当用户打算更新版本时，需要将新版本文件推送到本地仓库，再推送到云端仓库。用户也可以多次将新版本推送到本地仓库，再统一推送到云端仓库。因此所云端服务器崩溃，不影响用户的版本控制。
在本地安装 Git 后，可以在本地进行版本控制；若要将版本代码上传至云端仓库，需要链接 Github, Gitlab 账户等。
2. Git 三大分区 Git 有三种状态，你的文件可能处于其中之一： 已暂存（staged）、已修改（modified） 和已提交（committed） 。
 已修改（modified）表示修改了文件，但还没保存到数据库中。 已暂存（staged）表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交（committed）表示数据已经安全地保存在本地数据库中。  这会让我们的 Git 项目拥有三个阶段：工作区、暂存区、版本库。基本的 Git 工作流程如下：
 在工作区中修改文件，文件状态变为 modified。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区，文件状态变为 staged。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录，文件状态变为 committed。  3. Git 命令基础 本文以文件 ~/Documents/git_test/items.py 为例，如下：
3.0 忽略 .DS_Store 文件 Mac OS 系统会自动在每个目录中生成一个隐藏的 .DS_Store 文件。默认情况下 Git 会把 DS_Store 文件代入版本控制的范围内，从而与 Git 中的某些功能产生冲突。所以，需要在对项目进行版本管理之前设置 Git 忽略.</description>
    </item>
    
    <item>
      <title>Python Data Manipulate</title>
      <link>/post/2019/07/08/python-data-manipulate/</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/07/08/python-data-manipulate/</guid>
      <description>Overview df.head(x) df.info() df.describe() df.shape df.values df.columns df.index df.sort_values(by=&amp;#34;col&amp;#34;).tail(n) # n largest, e.t. df.nlargest(n, &amp;#34;col&amp;#34;) df.sample(n) # Return n random samples df.sample(frac=0.3) # Return a random sample of 30 percent df.sample(frac=1) # Shuffle df.corr() df.diff() Sort df.sort_values( by=&amp;#34;col_name&amp;#34;, axis=0, ascending=True, inplace=False ) df.sort_values( by=[&amp;#34;col1&amp;#34;, &amp;#34;col2&amp;#34;, &amp;#34;col3&amp;#34;], ascending=[True, False, True] # sort col1 by ascending; sort col2 by descending; sort col3 by ascending ) df.sort_index( level=[&amp;#34;outter_index&amp;#34;, &amp;#34;inner_index&amp;#34;], ascending=False ) Set index df.</description>
    </item>
    
    <item>
      <title>Python - 1. Data Manipulation with pandas</title>
      <link>/post/2018/08/08/python-1.-data-manipulation-with-pandas/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/08/08/python-1.-data-manipulation-with-pandas/</guid>
      <description>import pandas as pd import numpy as np 1. Transforming DataFrames 1.1 Introducing DataFrames Inspecting a DataFrame When you get a new DataFrame to work with, the first thing you need to do is explore it and see what it contains. pandas has several methods for this.
head method (.head()) returns the first few rows of the DataFrame.
# create a DataFrame cate = [&amp;#34;Py&amp;#34;, &amp;#34;R&amp;#34;, &amp;#34;Matlab&amp;#34; ] df = pd.</description>
    </item>
    
  </channel>
</rss>
